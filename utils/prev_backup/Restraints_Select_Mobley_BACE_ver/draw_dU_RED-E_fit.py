
from scipy import optimize
import matplotlib
matplotlib.use('AGG')
import matplotlib.pyplot as plt
import sys 
import numpy as np
import timeit
import pandas as pd
import os
import re

class RED_FIT():
    '''Restraint Energy Distribution(RED) function based fitting for the delta_U probability distribution.

    '''
    def __init__(self, d_u, bins=100):
        '''Initializing
        
        Parameters
        ----------
        d_u: array_like
            A series of delta_U values ((U_restrained - U_free) or (U_restrained - U_free)) with unit of kbT.
        bins: int, default: 100
            The bins used to generate the histogram of d_u.
        
        Key properties
        ----------
        self.u_l: np.array
            A series of delta_U values ((U_restrained - U_free) or (U_restrained - U_free)) with unit of kbT. 
            Its initial value was as same as the d_u. Then self.u_l will be filtered and reserve the delta_U, which is smaller than the five times of the theoretical mean of the delta_U (In RED function, the mean of delta_U is equal to the 2 times of the delta_U values with the highest probability.)
        self.pu_arr_orig: array_like
            The normalized probability of the original d_u generated by the np.histogram(self.u_l, bins=bins, density=True) (before filteration of self.u_l )
        self.xu_orig: np.array
            It have the same shape of self.pu_arr_orig, in which everyone is the midpoint value of each bin.
        self.pu_arr: np.array
             The normalized probability of the filtered d_u generated by the np.histogram(self.u_l, bins=bins, density=True) (after filteration of self.u_l )
        self.xu_arr: np.array
            It have the same shape of self.pu_arr, in which everyone is the midpoint value of each bin.
        self.u_mean: float
            The actual mean value of the filtered self.u_l
        self.u_std: float
            The actual standard deviation of the filtered self.u_l
        '''
        self.u_l=np.array(d_u)
        self.u_mean = np.mean(self.u_l)
        self.pu_arr_orig,xu_arr_add1_orig = np.histogram(self.u_l,bins=bins,density=True)
        xu_orig = []
        for i in range(len(xu_arr_add1_orig)-1):
            xu_orig.append((xu_arr_add1_orig[i]+xu_arr_add1_orig[i+1])/2)
        self.xu_arr_orig = np.array(xu_orig)        
        y_max = self.pu_arr_orig.max()
        #print (np.where(self.pu_arr_orig == y_max))
        #print (np.where(self.pu_arr_orig == y_max)[0])
        index = int(np.where(self.pu_arr_orig == y_max)[0][0])
        #print (index)
        x_max = self.xu_arr_orig[index] #the point with the highest y value
        
        mean = 2 * x_max # can be derived based on the equation b^2*exp(-bx)*x
        # self.u_l = self.u_l[self.u_l< (6*mean)]
        self.b_guess_by_max = 1/x_max
        
        self.pu_arr,xu_arr_add1 = np.histogram(self.u_l,bins=bins,density=True)
        xu = []
        for i in range(len(xu_arr_add1)-1):
            xu.append((xu_arr_add1[i]+xu_arr_add1[i+1])/2)

        self.xu_arr = np.array(xu)
        self.b_guess_by_mean = 2/self.u_mean
        # self.pu_arr = self.pu_arr/self.b_guess_by_max
        # self.xu_arr = self.xu_arr/self.b_guess_by_max
        self.pu_arr = self.pu_arr[self.xu_arr< (5*mean)]
        self.xu_arr = self.xu_arr[self.xu_arr< (5*mean)]

        where_are_inf = np.isinf(self.u_l)
        if self.u_mean > 0:
            self.u_l[where_are_inf] = 999.0
        else:
            self.u_l[where_are_inf] = -999.0

        self.u_std = np.std(self.u_l)

        self.sampled_u_mean = np.sum(self.pu_arr * self.xu_arr) / np.sum(self.pu_arr)
        self.sampled_u_std  = np.sqrt(np.sum(self.pu_arr * (self.xu_arr - self.sampled_u_mean)**2) / np.sum(self.pu_arr))
        self.sampled_u_value_y_max  = x_max
      
        
    def residues_common(self,p,f,y,x):
        '''Calculate the sum of squares of the difference between the model predicted value and the actual sampled value.

        Parameters
        ----------
        p: np.array or float
            The parameter that may be optimized in the function.
        f: function
            The function receive p and x to get the predicted y.
        y: np.array
            The acutal sampled values.
        x: np.array
            The independent variable of the function.
        
        Return
        ----------
        np.sum((y-f(p,x))**2)
        '''
        return np.sum((y-f(p,x))**2)

    def gm4rd(self,p,x):
        '''Restraint energy distribution (RED) function. $P\left(\Delta U_{i+1, i}\right)=b^{2} \exp \left(-b \Delta U_{i+1, i}\right) \cdot\left(\Delta U_{i+1, i}\right)$
        RED function's distribution property: U_mean = 2/b; U_max = 1/b; U_std = 2^(1/2)/b
                
        Parameters
        ----------
        p: np.array
            The parameter that may be optimized in the function, which only contain the b1.
        x: np.array
            The independent variable of the function. (In RED function, they are series of delta_U)
 
        Return
        ----------
        (b1**2) * abs(x) * np.exp(-b1 * abs(x))
        '''
        b1 = p[0]
        #return  np.exp(b1-a1) * x**2 * np.exp(-b1 * x - c1 * x**10)
        return (b1**2) * abs(x) * np.exp(-b1 * abs(x) )  #b1**2 term is for normalization                                           
                        
    def residues_rd(self,p,f,y,x):
        '''
        Not finished
        '''
        # return np.sum(((y-f(p,x))**2)*np.exp(y))# To make the large y have great weight when optimizing cost
        # return np.sum(((y-f(p,x))*self.u_mean*self.u_mean)**2)# To plus u_mean twice for f(p,x)=4*abs(x)*np.exp(-b * abs(x)) because u_mean = 2/b
        return np.sum(((y-f(p,x))*self.u_mean/2)**2)# The larger u_mean will lead to the larger u_std since U_mean = 2/b and U_std = 2^(1/2)/b. For getting the distribution with small u_mean(u_std) when ranking.
        # return np.sum(((y-f(p,x))*((self.u_mean/2)**2)*np.exp((2/self.u_mean)*x))**2)
        # return np.sum(((y-f(p,x))*((self.u_mean/2)**2)/np.exp(-1))**2)
        # return np.sum(((y-f(p,x*self.u_mean/2))*self.u_mean/2)**2)
        # return  np.sum(((y-f(p,x))**2)/x)
        # return np.sum((y-f(p,x))**2)


    def func_fit(self,func,p0,residues,add00=False):
        '''Relatively common curve fitting method.

        Parameters
        ----------
        func: function
            The function receive p and x to get the predicted y, as the second parameter of resides.
        p0: np.array or float
            The parameter that may be optimized in the function.
        residues: function
            The cost function which receive the optimized parameter, the potential functions that describe probability distributions, the distribution x and y for fitting. 
        add00: bool
            Judge if the do the edge smoothing.
        
        Return
        ----------
        plsq_full: tuple
            The tuple contains 5 elements. We need the first and second element. The first element is a np.array containing the parameter that was optimized in the function. The second element is the final cost function's value. 
        '''
        fit_xu_arr=self.xu_arr
        fit_pu_arr=self.pu_arr
        
        if add00:
            fit_xu_arr = np.append(fit_xu_arr,0.0)
            fit_pu_arr = np.append(fit_pu_arr,0.0)
            if self.u_mean > 0:            
                maxval = fit_xu_arr.max()
                for i in range(5):
                    fit_xu_arr = np.append(fit_xu_arr,maxval+0.5*(i+1))
                    fit_pu_arr = np.append(fit_pu_arr,0.0)
            else:
                minval = fit_xu_arr.min()
                for i in range(5):
                    fit_xu_arr = np.append(fit_xu_arr,minval-0.5*(i+1))
                    fit_pu_arr = np.append(fit_pu_arr,0.0)
        plsq_full = optimize.fmin(residues, p0, args=(func, fit_pu_arr, fit_xu_arr),maxiter=100000, full_output=True)
        # plsq_full = optimize.minimize(residues, p0, args=(func, fit_pu_arr, fit_xu_arr),maxiter=100000, full_output=True)
        return plsq_full


    def rd_fit(self):
        '''Restraint energy distribution fit. We derived the relationship between the mean delta_U and b1 based on the RED function, which is 
$\begin{aligned}
\langle\Delta U\rangle &=\int_{0}^{\infty} \Delta U \cdot P(\Delta U) d \Delta U \\
&=\int_{0}^{\infty} b^{2} \cdot \Delta U^{2} \cdot e^{-b \Delta U} d \Delta U \\
&=\frac{2}{b}
\end{aligned}$ 
For the initial guess value b1 in the RED function, we used the value of 2/<delta_U>.

        Generated or update properties
        ----------
        self.x: np.array
            10000 points between 0 and the maximum value of self.u_l (when the mean value of self.u_l is greater than 0), or 10000 points between the minimum value of self.u_l and 0 (when the mean value of self.u_l is less than 0)
        self.fitted_y: np.array
            A series of predicted probability values obtained by substituting self.x into the RED function.
        self.fitted_u: np.array
            Based on the probability distribution generated by self.fitted_y and self.x resampling, each bin value in self.x is repeated 1000 times according to the corresponding self.fitted_y.
        
        Return 
        ----------
        fopt: float
            The cost value of the RED function fitting.
        '''
        b1=2/self.u_mean
        p0=np.array([b1,])
        plsq_collect=self.func_fit(self.gm4rd,p0,self.residues_rd,add00=True)
        print('plsq_collect:')
        print(plsq_collect)
        # plsq_collect=self.func_fit(self.gm4rd,p0,self.residues_rd,add00=True)
        plsq=plsq_collect[0]
        fopt=plsq_collect[1]

        self.fitted_b = plsq_collect[0][0]
        self.theo_u_mean = 2/self.fitted_b 
        self.theo_u_value_y_max = 1/self.fitted_b
        self.theo_u_std  = 2**(0.5)/self.fitted_b
        if self.u_mean > 0:
            self.x = np.linspace(0, 1.0*self.u_l.max(),10000)
        else:
            self.x = np.linspace(1.0*self.u_l.min(),0, 10000)
        self.fitted_y = self.gm4rd(plsq,self.x)  
        # self.fitted_y = self.gm4rd(plsq,self.x*self.u_mean/2)*self.u_mean/2 
        self.fitted_u=[]
        for i in range(len(self.x)):
            self.fitted_u += [self.x[i] for j in range(int(round(self.fitted_y[i]*1000.0)))]
        self.fitted_u=np.array(self.fitted_u)
        
        return fopt
        
    def show_fit(self,pngfile,show_ori=True):
        '''Show the scatter points used for the fit, all the original scatter points (optional) and the fitted curve(RED function).

        Parameters
        ---------- 
        pngfile: str
            The name of the output png file.
        show_ori: bool
            If show all the original scatter points.       
        '''
        plt.clf()
        plt.figure(figsize=(16.2,12))
        #plt.title("Fitted probability distribution", fontsize=40) 
        #plt.xlabel("delta_U/${k_B}$T", fontsize=40) 
        #plt.ylabel("Probability density", fontsize=40) 
        plt.tick_params(labelsize=33, width=6.0, length=8.0)
        ax=plt.gca()
        ax.spines['bottom'].set_linewidth(4)
        ax.spines['left'].set_linewidth(4)
        ax.spines['right'].set_linewidth(4)
        ax.spines['top'].set_linewidth(4)
        print(f'best fit: b_guess_by_mean: {self.b_guess_by_mean}, b_guess_by_max: {self.b_guess_by_max}, fitted_b: {self.fitted_b}')
        plt.plot(self.xu_arr,self.pu_arr,"o", color = "green", markersize=10)
        if show_ori:
            plt.plot(self.xu_arr_orig, self.pu_arr_orig, "o", color = "gray", markersize=10)
        else:
            pass
        plt.plot(self.x, self.fitted_y, color='red', linewidth=5)

        if not pngfile:
            plt.show()
        else:
            plt.savefig(pngfile, transparent=True)

    def show_original_data(self):
        '''Show the original scatter points plot
        '''
        plt.clf()
        plt.figure(figsize=(16.2,12))
        plt.tick_params(labelsize=33, width=6.0, length=8.0)
        ax=plt.gca()
        ax.spines['bottom'].set_linewidth(4)
        ax.spines['left'].set_linewidth(4)
        ax.spines['right'].set_linewidth(4)
        ax.spines['top'].set_linewidth(4)
        plt.plot(self.xu_arr,self.pu_arr,"o")  
        plt.show()


class Draw_du_RED_FIT():
    def __init__(self, filename):
        self.filename = filename

    def read_csv_file(self, index_col=[0,1,2,3], delimiter='|'):
        single_df = pd.read_csv(self.filename, index_col=index_col, delimiter=delimiter)
        old_columns = list(single_df.columns)        
        if isinstance(old_columns[0], str):   
            regex_pattern = r"\((.*?)\)"
            new_columns = [eval(f'({re.findall(regex_pattern, column)[0]})') for column in old_columns]
        elif isinstance(old_columns[0], list):
            new_columns = [tuple(column) for column in old_columns]
        elif isinstance(old_columns[0], tuple):
            new_columns = old_columns
        single_df.columns = new_columns
        self.single_df = single_df
    
    def get_du(self,index_col=[0,1,2,3], delimiter='|'):
        self.read_csv_file(index_col=index_col, delimiter=delimiter)
        self.du = np.array(self.single_df.iloc[:,-1] - self.single_df.iloc[:, 0])
        return self.du#in kbT unit

    def RED_fit(self, png_file='best_s0.png'):
        du = self.get_du()
        self.w_fit=RED_FIT(du,bins=100)
        self.fopt=self.w_fit.rd_fit()

        exponential=np.exp(self.du*(-1))
        expave=exponential.mean()
        self.dG=-np.log(expave)*0.592# in kcal/mol
        print(f'cost: {self.fopt}')
        print(f'dG: {self.dG}')
        self.w_fit.show_fit(str(png_file), True) 

if __name__ == '__main__':
    ts = Draw_du_RED_FIT('state_s0.csv')
    ts.RED_fit()
